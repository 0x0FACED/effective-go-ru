# Effective Go (Translated to Russian)

Это переведенный на русский язык Effective Go.

## Содержание

- [Effective Go (Translated to Russian)](#effective-go-translated-to-russian)
  - [Содержание](#содержание)
  - [Форматирование](#форматирование)
    - [Отступы](#отступы)
    - [Длина строки](#длина-строки)
    - [Круглые скобки](#круглые-скобки)
  - [Комментирование](#комментирование)
  - [Имена](#имена)
    - [Имена пакетов](#имена-пакетов)
    - [Геттеры (Getters)](#геттеры-getters)
    - [Имена интерфейсов](#имена-интерфейсов)
    - [MixedCaps](#mixedcaps)
  - [Точки с запятой](#точки-с-запятой)
  - [Управляющие конструкции](#управляющие-конструкции)
    - [If](#if)
    - [Повторное объявление и присваивание](#повторное-объявление-и-присваивание)
    - [For](#for)
    - [Switch](#switch)
    - [Type switch](#type-switch)
  - [Функции](#функции)
    - [Множественные возвращаемые значения](#множественные-возвращаемые-значения)
    - [Именованные параметры результата](#именованные-параметры-результата)
    - [Отложенные вызовы (defer)](#отложенные-вызовы-defer)
  - [Данные](#данные)
    - [Выделение (аллокация) памяти с помощью `new`](#выделение-аллокация-памяти-с-помощью-new)
    - [Конструкторы и составные литералы](#конструкторы-и-составные-литералы)
    - [Выделение (аллокация) памяти с помощью `make`](#выделение-аллокация-памяти-с-помощью-make)
    - [Массивы](#массивы)
    - [Слайсы (Срезы, Slices)](#слайсы-срезы-slices)
    - [Двумерные срезы](#двумерные-срезы)
    - [Карты](#карты)
    - [Печать](#печать)
    - [Добавление (Append)](#добавление-append)
  - [Инициализация (Initialization)](#инициализация-initialization)

## Форматирование

Вопросы форматирования - самые спорные, но **наименее значимые**. Люди могут приспособиться к разным стилям форматирования, но лучше, если им не придется этого делать, и меньше времени будет уделено теме, если все будут придерживаться одного стиля. Проблема в том, как подойти к этой утопии без длинного предписывающего руководства по стилю.

В Go мы используем необычный подход и позволяем машине позаботиться о большинстве вопросов форматирования. Программа `gofmt` (также доступная как `go fmt`, которая работает на уровне пакетов, а не исходных файлов) читает программу на Go и выдает исходный текст в стандартном стиле с отступами и вертикальным выравниванием, сохраняя и при необходимости переформатируя комментарии. Если вы хотите узнать, как поступить в новой ситуации с версткой, запустите `gofmt`; если ответ покажется вам неправильным, перестройте свою программу (или напишите об ошибке в `gofmt`), а не обходите ее. 

Например, не нужно тратить время на выстраивание комментариев к полям структуры. `Gofmt` сделает это за вас. Учитывая тэту структуру

```go
type T struct {
    name string // имя объекта
    value int // его значение
}
```

`gofmt` выстроит столбцы в ряд:

```go
type T struct {
    name    string  // имя объекта
    value   int     // его значение
}
```

Весь код Go в стандартных пакетах был отформатирован с помощью `gofmt`.

Некоторые детали форматирования остались. **Очень коротко:**

### Отступы

Мы используем табуляции для отступов, и `gofmt` выдает их по умолчанию. Используйте пробелы только в случае необходимости. 

### Длина строки

В Go нет ограничений на длину строки. Не бойтесь переполнить перфокарту. Если строка кажется слишком длинной, оберните ее и сделайте отступ с помощью дополнительной табуляции. 

Пример:

```go
package main

import "fmt"

func main() {
    // Длинная строка без переноса
    fmt.Println("This is an example of a very long line of code in Go that exceeds the usual length limit and should be wrapped according to best practices for readability and maintainability.")
}

```

```go
package main

import "fmt"

func main() {
    // Длинная строка с множественными переносами
    fmt.Println(
        "This is an example of a very long line of code in Go that exceeds " + 
        "the usual length limit and should be wrapped "+ 
        "according to best practices for readability " +
        "and maintainability.",
    )
}


```

### Круглые скобки

В Go требуется меньше круглых скобок, чем в C и Java: управляющие структуры (if, for, switch) не содержат круглых скобок в своем синтаксисе. Кроме того, иерархия старшинства операторов короче и понятнее, так что

    x<<8 + y<<16

означает то, что подразумевает интервал, в отличие от других языков.

## Комментирование

В Go предусмотрены блочные комментарии `/* */` в стиле `C` и строчные комментарии `//` в стиле `C++`. Строчные комментарии являются нормой; блочные комментарии появляются в основном как комментарии к пакетам, но они полезны внутри выражения или для отключения больших участков кода.

Комментарии, появляющиеся перед декларациями верхнего уровня, без промежуточных строк, считаются документированием самой декларации. Эти «doc-комментарии» являются основной документацией для данного пакета или команды Go. Подробнее о комментариях см. в разделе [Комментарии к документам Go](https://go.dev/doc/comment).

## Имена

Имена важны в Go, как и в любом другом языке. Они даже имеют семантический эффект: **видимость имени вне пакета определяется тем, является ли его первый символ верхним регистром**. Поэтому стоит уделить немного времени обсуждению соглашений об именовании в программах на Go.

### Имена пакетов

Когда пакет импортируется, его имя становится указателем доступа к его содержимому. После импорта пакета:

```go
import "strings"
```

Мы можем использовать его содержимое:

```go
package main

import "strings"

func main() {
    str := "This is the new string!"
    words := strings.SplitN(str, " ", 3)
    // words = ["This","is","the new string!"]
}
bytes.Clone()

```

Мы обращаемся к **экспортируемым** функциям/переменным/структурам через имя пакета. Это удобно, так как все, кто будут использовать этот пакет, будут использовать одинаковое обращение к его содержимому, что подразумевает, что имя пакета должно быть хорошим: коротким, лаконичным, вызывающим. По соглашению, пакетам присваиваются имена в нижнем регистре, состоящие из одного слова; подчеркивания или смешанные прописные буквы не нужны. Отдавайте предпочтение краткости, поскольку все, кто будет использовать ваш пакет, будут набирать это имя. И не беспокойтесь о коллизиях априори. Имя пакета - это только имя по умолчанию для импорта; оно не обязательно должно быть уникальным во всем исходном коде, и в редких случаях коллизии импортирующий пакет может выбрать другое имя для локального использования. 

Например: 

```go
import (
    "strings"
    "github.com/exampleuser/examplelibrary/strings"
    // Будет конфликт, так как оба пакета имеют одинаковые имена указателей доступа.
    // strings и strings
)
```

Сделаем так:

```go
import (
    "strings"
    strings2 "github.com/exampleuser/examplelibrary/strings"
    // Конфликта не будет, как ты локально дали другое название пакету.
)
```

В любом случае, путаница возникает редко, поскольку имя файла в импорте определяет, какой именно пакет используется.

Другое соглашение заключается в том, что имя пакета является базовым именем его исходного каталога; пакет в `src/encoding/base64` импортируется как `"encoding/base64"`, но имеет имя `base64`, а не `encoding_base64` и не `encodingBase64`.

Импортер пакета будет использовать это имя для ссылки на его содержимое, поэтому экспортируемые имена в пакете могут использовать этот факт, чтобы избежать повторений. (Не используйте нотацию `import .`, которая может упростить тесты, которые должны выполняться вне проверяемого пакета, но в остальном ее следует избегать). Например, `buffered reader type` в пакете `bufio` называется `Reader`, а не `BufReader`, потому что пользователи видят его как `bufio.Reader`, **что является ясным и кратким именем**. Более того, поскольку к импортируемым сущностям всегда обращаются по имени их пакета, `bufio.Reader` не конфликтует с `io.Reader`. Аналогично, функция создания новых экземпляров `ring.Ring` - а это определение конструктора в Go - обычно называется `NewRing`, но поскольку `Ring` - единственный тип, экспортируемый пакетом, и поскольку пакет называется `ring`, она называется просто `New`, что клиенты пакета видят как `ring.New`. Используйте структуру пакета, чтобы помочь вам выбрать хорошие имена.

Например, у нас есть пакет `internal/server`, где лежит структура сервера и есть функция, которая создает объект этого сервера. так как мы будем обращаться к содержимому пакета через `server`, во всех экспортируемых именах не стоит ипсользовать `server`.

```go
package server

type server struct {
    // ...
}

func New(...) *server {
    return &server{
        ...
    }
}

// ...
```

```go
package client

import ".../internal/server"

func main() {
    s := server.New(...)
    // ...
}
```

***Что здесь у нас?*** 

У нас есть пакет со структурой сервера и функция, которая инициализирует объект сервера и возвращает указатель на него. **Структура НЕэкспортируемая, а функция экспортируемая**. В другом месте мы импортируем пакет сервера и хотим создать сервер + получить на него указатель. Мы вызываем `server.New()`, **что уже явно говорит нам, что создается именно сервер**. Не надо делать никаких `NewServer()` и других.

Конечно, если будет еще другая структура в этом пакете и у нее будет функция `New()`, то тогда придется выбрать другое название. **А вообще надо просто создать отдельный пакет для этой структуры и всего, что с ней связано.**

### Геттеры (Getters)

Go не предоставляет автоматической поддержки геттеров и сеттеров. Нет ничего плохого в том, чтобы предоставлять геттеры и сеттеры самостоятельно, и часто это бывает уместно, **но нет ни идиоматизма, ни необходимости добавлять Get в имя геттера**. Если у вас есть поле с именем `owner` (**нижний регистр, неэкспортированное**), **метод геттера должен называться `Owner`** (**верхний регистр, экспортированное**), **а не** `GetOwner`. Использование имен в верхнем регистре при экспорте дает крючок для различения поля и метода. Функция сеттера, если она необходима, скорее всего, будет называться `SetOwner`. Оба имени хорошо читаются на практике:
```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Имена интерфейсов

По соглашению, интерфейсы с одним методом называются по имени метода с добавлением суффикса `-er` или аналогичного изменения для образования существительного-агента: `Reader`, `Writer`, `Formatter`, `CloseNotifier` и т.д.

Существует множество таких имен, и важно уважать их и функции, которые они описывают. `Read`, `Write`, `Close`, `Flush`, `String` и так далее **имеют канонические сигнатуры и значения**. Чтобы избежать путаницы, не давайте вашему методу одно из этих имен, если у него нет такой же сигнатуры и значения. Напротив, если ваш тип реализует метод с тем же значением, что и метод в известном типе, дайте ему такое же имя и сигнатуру; назовите ваш метод преобразования строки `String`, а не `ToString`.

***Что за канонические сигнатуры и значения?***

В Go существуют **стандартные (канонические) имена и сигнатуры методов для интерфейсов**. Например, методы `Read`, `Write`, `Close`, и `String` имеют общепринятые значения и способы использования в языке. 

Вот что это означает:

1. *Стандартные имена и сигнатуры*. Методы с определенными именами имеют ожидаемые сигнатуры (определение параметров и возвращаемых значений). Например, метод `Read` в стандартной библиотеке имеет сигнатуру `Read(p []byte) (n int, err error)`, **что означает, что он читает данные в срез байтов и возвращает количество прочитанных байтов и ошибку**.

2. *Согласованность и предсказуемость*. Когда вы используете стандартные имена и сигнатуры, это делает ваш код предсказуемым и совместимым с другими пакетами и библиотеками, которые следуют тем же стандартам. Это помогает другим разработчикам быстрее понять ваш код и использовать его без необходимости разбираться в нестандартных соглашениях.

Не используйте стандартные имена без соответствия сигнатурам: не называйте ваш метод, например, `Read`, **если он не реализует ту же функциональность или сигнатуру, что и стандартный метод `Read`**. Если вы используете стандартное имя, оно должно точно соответствовать общепринятым стандартам, чтобы избежать путаницы. Например, метод `Read` должен принимать **срез байтов** и **возвращать количество прочитанных байтов и ошибку**, как это предусмотрено стандартом.

Соблюдайте соглашения для методов с известными именами: если ваш тип реализует метод, аналогичный методу в известных типах (например, `String` для метода, возвращающего строку), используйте те же имена и сигнатуры. Это делает ваш код согласованным с другими библиотеками и типами, что упрощает его использование и понимание. Например, метод, **который возвращает строковое представление вашего типа, должен называться `String`, а не `ToString`.**

### MixedCaps

Наконец, в Go принято использовать **MixedCaps** или **mixedCaps**, **а не подчеркивание для записи многословных имен**.

## Точки с запятой

Как и в `C`, в формальной грамматике Go используется точка с запятой для завершения операторов, но в отличие от C, эти точки с запятой не появляются в исходном коде. Вместо этого лексический анализатор **(Лексер)** использует простое правило для автоматического добавления точек с запятой во время сканирования, поэтому в тексте программы их почти нет.

Правило такое: *если последний токен перед новой строкой является идентификатором (включая такие слова, как int и float64), простым литералом, таким как число или строковая константа, или одним из следующих токенов:*

```go
break, continue, fallthrough, return, ++, --, ), },
```

*лексический анализатор всегда вставляет точку с запятой после этого токена.* Это можно резюмировать так: **«если новая строка идет после токена, который может завершать оператор, вставьте точку с запятой»**.

Точку с запятой также можно опустить непосредственно перед закрывающей скобкой, поэтому оператор, такой как

```go
go func() { for { dst <- <-src } }()
```

не требует точек с запятой. Идиоматические программы на Go содержат точки с запятой только в таких местах, как условие в цикле for, чтобы разделить инициализацию, условие и продолжение. Они также необходимы для разделения нескольких операторов в одной строке, если вы пишете код таким образом.

Одним из последствий правил вставки точек с запятой является то, **что вы не можете ставить открывающую скобку управляющей структуры (if, for, switch или select) на следующей строке**. Если вы это сделаете, точка с запятой будет вставлена перед скобкой, что может вызвать нежелательные эффекты. Пишите их так:

```go
if i < f() {
    g()
}
```

**а не так:**

```go
if i < f()  // неправильно!
{           // неправильно!
    g()
}
```

***Почему именно так?***

Потому что `if i < f()` не заканчивается во втором случае открывающей скобкой, а **значит условие окончено**, а значит лексер поставит точку с запятой. Когда лексер видит конструкцию вида `if i < f() {`, он понимает, что дальше идет тело условия.

*Лексический анализатор сам расставляет точки с запятой перед компиляцией.*

## Управляющие конструкции

Управляющие конструкции в Go похожи на те, что используются в `C`, но имеют важные отличия. В Go нет циклов `do` или `while`, есть только немного более универсальный `for`; конструкция `switch` более гибкая; `if` и `switch` могут принимать необязательный оператор инициализации, подобно `for`; операторы `break` и `continue` могут принимать необязательную метку, чтобы указать, какую конструкцию завершить или продолжить; также есть новые управляющие конструкции, включая `type switch` и мультиплексор многоканальной связи `select`. Синтаксис также немного отличается: **в Go нет круглых скобок**, а **тело конструкций всегда должно быть заключено в фигурные скобки**.

### If

В Go простая конструкция `if` выглядит так:

```go
if x > 0 {
    return y
}
```

Обязательное использование фигурных скобок поощряет написание простых операторов `if` на нескольких строках. **Это хороший стиль, особенно когда тело содержит управляющий оператор, такой как `return` или `break`.**

Поскольку `if` и `switch` могут принимать оператор инициализации, часто можно увидеть, как его используют для создания локальной переменной.

```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

В библиотеках Go вы заметите, что если оператор `if` не переходит к следующему оператору — то есть, если тело заканчивается `break`, `continue`, `goto` или `return` — **то лишний `else` опускается.**

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

Это пример распространенной ситуации, когда код должен защититься от ряда ошибок. Такой код легко читается, если успешное выполнение продолжается вниз по странице, устраняя случаи ошибок по мере их возникновения. Поскольку случаи ошибок обычно заканчиваются операторами `return`, итоговый код не нуждается в операторах `else`.

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

*Пример `type switch`*:

```go
func process(value interface{}) {
    switch v := value.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type\n")
    }
}
```

### Повторное объявление и присваивание

Отступление: последний пример в предыдущем разделе демонстрирует одну деталь, касающуюся того, как работает краткая форма объявления `:=`. Объявление, которое вызывает `os.Open`, выглядит так:

```go
f, err := os.Open(name)
```

Эта инструкция объявляет две переменные: `f` и `err`. Несколькими строками ниже вызов `f.Stat` выглядит так:

```go
d, err := f.Stat()
```

что, на первый взгляд, кажется объявлением переменных `d` и `err`. Обратите внимание, однако, что `err` появляется в обоих выражениях. Это дублирование допустимо: `err` объявляется первым оператором, но во втором только повторно присваивается. Это означает, что вызов `f.Stat` использует существующую переменную `err`, объявленную выше, и просто присваивает ей новое значение.

В декларации `:=` переменная `v` может появляться, даже если она уже была объявлена, при условии, что:

1. Это объявление находится в той же области видимости, что и существующее объявление `v` (если `v` уже объявлена во внешней области видимости, то объявление создаст новую переменную).
2. Соответствующее значение в инициализации может быть присвоено `v`.
3. По крайней мере одна другая переменная создается этим объявлением.

**Это необычное свойство является чистым прагматизмом**, что упрощает использование единственного значения `err`, например, в длинной цепочке `if-else`. Вы часто увидите его использование.

*Примечание: стоит отметить, что в Go область видимости параметров функции и возвращаемых значений совпадает с областью видимости тела функции, даже если они появляются лексически вне фигурных скобок, заключающих тело.*

### For

Цикл `for` в Go похож на цикл в языке `C`, но не идентичен ему. В Go объединены конструкции `for` и `while`, и отсутствует конструкция `do-while`. **Существует три формы цикла `for`, и только в одной из них используются точки с запятой**.

```go
// Как for в C
for init; condition; post { }

// Как while в C
for condition { }

// Как for(;;) в C
for { }
```

Краткие объявления позволяют легко объявлять переменные-счетчики прямо в цикле.

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

Если вы итерируетесь по массиву, срезу, строке, карте или читаете из канала, оператор `range` может управлять циклом.

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

Если вам нужен только первый элемент в `range` (**ключ** или **индекс**), **опустите второй**:

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

Если вам нужен **только второй элемент в `range` (значение), используйте идентификатор-заглушку (подчеркивание) для отбрасывания первого**:

```go
sum := 0
for _, value := range array {
    sum += value
}
```

Идентификатор-заглушка имеет много применений, которые будут описаны в следующих разделах.

Для строк `range` выполняет дополнительную работу, **разбивая отдельные символы Unicode путем парсинга UTF-8**. Ошибочные кодировки потребляют один байт и выводят символ замены `U+FFFD`. (Термин `rune` (и связанный с ним встроенный тип) в Go обозначает **один кодовый пункт Unicode**. Подробнее см. в [спецификации языка](https://go.dev/ref/spec#Rune_literals).)

Цикл

```go
for pos, char := range "日本\x80語" { // \x80 - недопустимая кодировка UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```

выводит:

```go

character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

Наконец, **в Go нет оператора запятой, а ++ и -- — это операторы, а не выражения**. Поэтому, если вы хотите управлять несколькими переменными в `for`, **вы должны использовать параллельное присваивание (хотя это исключает использование ++ и --).**

```go
// Перевернуть массив a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch

Конструкция `switch` в Go более универсальна, чем в `C`. Выражения в `switch` **не обязательно должны быть константами или даже целыми числами**, случаи (`case`) проверяются **сверху вниз до тех пор, пока не будет найдено совпадение**, **и если в `switch` не указано выражение, он переключается на `true`**. Поэтому можно (и это является идиоматикой Go) написать цепочку `if-else-if-else` в виде `switch`.

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

Автоматического перехода к следующему случаю (**`fall through`**) нет, но можно указать несколько значений для одного случая через запятую.

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Хотя `break` в Go используется не так часто, как в некоторых других языках, похожих на `C`, его можно применять для досрочного завершения `switch`. Иногда, однако, требуется выйти из окружающего цикла, а не из `switch`, **и в Go это можно сделать, поместив метку на цикл и используя `break` с указанием этой метки.** Этот пример демонстрирует оба использования.

```go
Loop:
    for n := 0; n < len(src); n += size {
        switch {
        case src[n] < sizeOne:
            if validateOnly {
                break
            }
            size = 1
            update(src[n])

        case src[n] < sizeTwo:
            if n+1 >= len(src) {
                err = errShortInput
                break Loop
            }
            if validateOnly {
                break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
    }
```
Конечно, оператор `continue` также принимает необязательную метку, **но он применяется только к циклам**.

Для завершения этого раздела вот функция сравнения для срезов байтов, которая использует два оператора `switch`:

```go
// Compare возвращает целое число, сравнивающее два среза байтов
// в лексикографическом порядке.
// Результат будет 0, если a == b, -1, если a < b, и +1, если a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### Type switch

`Switch` **также может использоваться для определения динамического типа переменной интерфейса**. Такая проверка типа использует синтаксис проверки типа с ключевым словом `type` внутри скобок. Если `switch` объявляет переменную в выражении, эта переменная будет иметь соответствующий тип в каждом случае. Также **является идиоматическим переиспользование имени в таких случаях**, фактически объявляя новую переменную с тем же именем, но с другим типом в каждом случае.

```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("неожиданный тип %T\n", t)     // %T выводит тип переменной t
case bool:
    fmt.Printf("логическое значение %t\n", t)  // t имеет тип bool
case int:
    fmt.Printf("целое число %d\n", t)          // t имеет тип int
case *bool:
    fmt.Printf("указатель на логическое значение %t\n", *t) // t имеет тип *bool
case *int:
    fmt.Printf("указатель на целое число %d\n", *t) // t имеет тип *int
}
```

## Функции

### Множественные возвращаемые значения

Одной из необычных особенностей Go является то, что функции и методы могут возвращать несколько значений. Эта возможность может быть использована для улучшения некоторых неудобных идиом в программах на языке `C`: например, возврат ошибок с использованием специальных значений, таких как `-1` для обозначения конца файла (`EOF`), и изменение аргумента, переданного по адресу.

В `C` ошибка записи сигнализируется отрицательным числом, при этом код ошибки хранится в каком-то изменяемом месте. В Go метод `Write` **может вернуть количество записанных байтов и ошибку**: «Да, вы записали некоторые байты, **но не все, потому что заполнили устройство**». Сигнатура метода `Write` для файлов из пакета `os` выглядит следующим образом:

```go
func (file *File) Write(b []byte) (n int, err error)
```

И, как указано в документации, метод возвращает количество записанных байтов и ненулевую ошибку, когда `n != len(b)`. Это распространённый стиль; для получения дополнительных примеров обратитесь к разделу обработки ошибок.

**Аналогичный подход устраняет необходимость передавать указатель на возвращаемое значение, чтобы симулировать параметр-ссылку**. Вот простая функция, которая извлекает число из указанной позиции в срезе байтов, возвращая само число и следующую позицию.

```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

Вы могли бы использовать её для сканирования чисел в входном срезе `b` следующим образом:

```go
for i := 0; i < len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
```

### Именованные параметры результата

Возвращаемые или результативные «параметры» функции в Go могут иметь имена и использоваться как обычные переменные, так же, как и входящие параметры. **Когда им присваиваются имена, они инициализируются нулевыми значениями для их типов при начале выполнения функции; если функция выполняет оператор `return` без аргументов, то в качестве возвращаемых значений используются текущие значения параметров результата.**

Имена не являются обязательными, но они могут сделать код короче и понятнее: **они служат документацией**. Если мы дадим имена результатам функции `nextInt`, станет очевидно, какой из возвращаемых `int` является каким.

```go
func nextInt(b []byte, pos int) (value, nextPos int)
```

Поскольку именованные результаты инициализируются и привязаны к **неукрашенному `return`**, они могут не только упростить код, но и сделать его более ясным. Вот версия функции `io.ReadFull`, которая хорошо их использует:

```go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### Отложенные вызовы (defer)

Оператор `defer` в Go откладывает выполнение функции (отложенной функции) до момента, когда вызывающая её функция завершится и начнёт возвращать результат. Это необычный, но эффективный способ решения **таких задач, как освобождение ресурсов, которые должны быть освобождены независимо от того, каким образом функция завершает свою работу**. **Каноническими примерами являются разблокировка мьютекса или закрытие файла**.

```go
// Contents возвращает содержимое файла в виде строки.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close будет вызвана, когда функция завершит работу.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append будет написана позже.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f будет закрыт, если мы выйдем здесь.
        }
    }
    return string(result), nil // f будет закрыт, если мы выйдем здесь.
}
```

Откладывание вызова функции, такой как `Close`, имеет два преимущества. Во-первых, это гарантирует, что вы никогда не забудете закрыть файл, что легко сделать, если вы позже измените функцию, добавив новый путь возврата. Во-вторых, это означает, что закрытие файла находится рядом с его открытием, что делает код более понятным, чем если бы закрытие было размещено в конце функции.

Аргументы для отложенной функции (включая получателя, если функция является методом) вычисляются в момент выполнения `defer`, а не в момент вызова отложенной функции, **то есть в момент объявления блока `defer`**. Это позволяет избежать проблем с изменением значений переменных по мере выполнения функции, а также позволяет с помощью одного вызова `defer` отложить выполнение нескольких функций. Вот простой пример:

```go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
```

Отложенные функции выполняются в порядке **LIFO** (**Last In, First Out**), поэтому этот код выведет **4 3 2 1 0**, когда функция завершится. Более правдоподобный пример — простой способ отслеживания выполнения функций в программе. Мы могли бы написать несколько простых функций для трассировки:

```go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }
```

Использовать их можно так:

```go
func a() {
    trace("a")
    defer untrace("a")
    // что-то делаем...
}
```

Мы можем улучшить код, используя тот факт, что аргументы для отложенных функций вычисляются в момент выполнения defer. Функция трассировки может подготовить аргумент для функции отслеживания завершения. Этот пример:

```go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
```

выводит:

```
entering: b
in b
entering: a
in a
leaving: a
leaving: b
```

Для программистов, привыкших к управлению ресурсами на уровне блоков кода в других языках, `defer` может показаться странным, **но его самые интересные и мощные применения связаны с тем, что он работает на уровне функции, а не блока кода**. В разделе о `panic` и `recover` будет показан ещё один пример его возможностей.

## Данные

### Выделение (аллокация) памяти с помощью `new`

В Go есть два примитива выделения памяти: **встроенные функции `new` и `make`.** Они выполняют разные задачи и применяются к различным типам, что может быть немного запутанным, но правила просты. Сначала поговорим о `new`. Это встроенная функция, **которая выделяет память, но, в отличие от аналогичных функций в некоторых других языках, она *не инициализирует* память, а лишь *обнуляет* её**. То есть `new(T)` выделяет память для нового объекта типа `T`, обнуляет её и возвращает его адрес, значение типа `*T`. В терминологии Go, она возвращает указатель на только что выделенное нулевое значение типа `T`.

Поскольку память, возвращаемая `new`, обнулена, полезно при проектировании ваших структур данных предусмотреть, чтобы нулевое значение каждого типа можно было использовать без дальнейшей инициализации. Это означает, что пользователь структуры данных может создать её с помощью `new` и сразу начать работу. Например, в документации для `bytes.Buffer` говорится, что "**нулевое значение для `Buffer` — это пустой буфер, готовый к использованию**". Аналогично, `sync.Mutex` не имеет явного конструктора или метода `Init`. **Вместо этого нулевое значение для `sync.Mutex` определяется как разблокированный мьютекс.**

Свойство "**нулевое значение полезно**" работает транзитивно. Рассмотрим это объявление типа.

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

Значения типа `SyncedBuffer` также готовы к использованию сразу после выделения или просто объявления. В следующем фрагменте кода и `p`, и `v` будут работать корректно без дальнейшей настройки.

```go
p := new(SyncedBuffer)  // тип *SyncedBuffer
var v SyncedBuffer      // тип  SyncedBuffer
```

*Транзитивность означает, что при объявлении через `new` или как `var` **поля структуры будут обнулены, то есть нулевыми, то есть у каждого поля в зависимости от типа будет нулевое значение.***

### Конструкторы и составные литералы

Иногда нулевое значение недостаточно, и необходим конструктор для инициализации, как в следующем примере из пакета `os`.

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

В этом примере много шаблонного кода (так называемый `boilerplate code`). Мы можем упростить его, **используя составной литерал, который является выражением, создающим новый экземпляр при каждом его выполнении.**

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

Обратите внимание, что в отличие от `C`, **возвращать адрес локальной переменной в Go вполне допустимо**; **память**, связанная с переменной, **сохраняется после завершения функции**. На самом деле, **взятие адреса составного литерала выделяет новый экземпляр при каждом выполнении, поэтому мы можем объединить последние две строки:**

```go
return &File{fd, name, nil, 0}
```

**Поля составного литерала располагаются в порядке и должны быть все указаны**. Однако, указывая элементы явно в виде пар "**поле: значение"**, инициализаторы могут быть в любом порядке, а пропущенные будут иметь нулевые значения. Так мы можем написать:

```go
return &File{fd: fd, name: name}
```

В качестве крайнего случая, если составной литерал не содержит полей, **он создаст нулевое значение для типа**. Выражения `new(File)` и `&File{}` ***эквивалентны***.

Составные литералы также могут быть созданы для массивов, срезов и карт, где метки полей будут индексами или ключами карты. В этих примерах инициализация работает независимо от значений `Enone`, `Eio` и `Einval`, если они уникальны.

```go
const Enone = 0
const Eio = 1
const Einval = 2
a := [...]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

### Выделение (аллокация) памяти с помощью `make`

Вернемся к выделению памяти. Встроенная функция `make(T, args)` имеет другую цель по сравнению с `new(T)`. Она создает **только срезы, карты и каналы и возвращает *инициализированное* (*а не обнуленное*) значение типа `T` (а не `*T`)**. Причина различия в том, что **эти три типа представляют собой ссылки на структуры данных, которые должны быть инициализированы перед использованием**. Например, *срез — это трехкомпонентный дескриптор, содержащий указатель на данные (внутри массива), длину и емкость, и пока эти элементы не инициализированы, срез равен `nil`*. Для срезов, карт и каналов функция `make` инициализирует внутреннюю структуру данных и подготавливает значение к использованию. Например,

```go
make([]int, 10, 100)
```

**выделяет массив из 100 целых чисел и затем создает структуру среза с длиной 10 и емкостью 100, указывающую на первые 10 элементов массива**. (При создании среза емкость можно опустить; см. раздел о срезах для получения дополнительной информации.) В отличие от этого, `new([]int`) возвращает указатель на только что выделенную, обнуленную структуру среза, то есть указатель на значение `nil` среза.

Эти примеры иллюстрируют разницу между new и make.

```go
var p *[]int = new([]int)       // выделяет структуру среза; *p == nil; редко полезно
var v  []int = make([]int, 100) // срез v теперь ссылается на новый массив из 100 целых чисел

// Неоправданно сложно (оно не надо, не делайте так):
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Идиоматично:
v := make([]int, 100)
```

Помните, что `make` **применяется только к картам, срезам и каналам и не возвращает указатель**. Чтобы получить явный указатель, используйте `new` или **явно возьмите адрес переменной**.


### Массивы

Массивы полезны при планировании детальной структуры памяти и иногда помогают избежать выделения памяти, но в основном они служат строительным блоком для срезов, которые будут обсуждаться в следующем разделе. Чтобы заложить основу для этой темы, вот несколько слов о массивах.

Есть значительные различия в том, как массивы работают в Go и `C`. В Go:

- *Массивы — это значения. Присваивание одного массива другому копирует все элементы.*
- *В частности, если передать массив в функцию, она получит копию массива, а не указатель на него.*
- *Размер массива является частью его типа. Типы `[10]int` и `[20]int` различны.*

Свойство ***"значения"*** может быть полезным, но также дорогим по ресурсам; **если вам нужно поведение и эффективность, как в `C`, можно передать указатель на массив.**

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Обратите внимание на явное использование оператора взятия адреса
```

Но даже этот стиль не является идиоматичным для Go. 

**Вместо этого используйте срезы.**

### Слайсы (Срезы, Slices)

**Срезы оборачивают массивы**, предоставляя более общий, мощный и удобный интерфейс к последовательностям данных. За исключением элементов с явными размерами, таких как матрицы преобразований, большинство программирования с массивами в Go осуществляется с использованием срезов, а не простых массивов.

Срезы содержат ссылки на лежащие в основе массивы, и если присвоить один срез другому, оба будут ссылаться на один и тот же массив. Если функция принимает аргумент в виде среза, изменения, которые она вносит в элементы среза, будут видны вызывающей стороне, аналогично передаче указателя на массив. Функция чтения (например, `Read`) может принять срез в качестве аргумента вместо указателя и количества данных; длина среза устанавливает верхний предел объема данных для чтения. Вот сигнатура метода `Read` типа `File` из пакета `os`:

```go
func (f *File) Read(buf []byte) (n int, err error)
```

Метод возвращает количество прочитанных байт и значение ошибки, если таковая имеется. Чтобы прочитать первые 32 байта из большего буфера `buf`, нужно просто "нарезать" буфер.

```go
n, err := f.Read(buf[0:32])
```

Такое нарезание является обычной практикой и очень эффективно. **Фактически, если оставить эффективность в стороне, следующий фрагмент кода также прочитает первые 32 байта буфера.**

```go
var n int
var err error
for i := 0; i < 32; i++ {
    nbytes, e := f.Read(buf[i:i+1])  // Чтение по одному байту.
    n += nbytes
    if nbytes == 0 || e != nil {
        err = e
        break
    }
}
```

Длину среза можно изменять, пока она укладывается в пределы исходного массива; для этого достаточно присвоить срез самому себе. Вместимость среза (доступная через встроенную функцию `cap`) показывает максимальную длину, которую может иметь срез. **Вот функция для добавления данных в срез. Если данных больше, чем позволяет вместимость, срез перераспределяется**. **Возвращается изменённый срез**. В функции используется тот факт, что для нулевого среза длина и вместимость равны 0.

```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // перераспределение
        // Выделяем память с запасом для будущего роста.
        newSlice := make([]byte, (l+len(data))*2)
        // Функция copy встроена и работает с любыми типами срезов.
        copy(newSlice, slice)
        slice = newSlice
    }
    
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
```

**Мы должны вернуть срез после изменения, потому что, хотя функция Append может изменять элементы среза, сам срез (структура, содержащая указатель, длину и вместимость) передается по значению.**

Идея добавления в срез настолько полезна, что она реализована во встроенной функции `append`. Чтобы понять дизайн этой функции, нам нужно немного больше информации, к которой мы вернёмся позже.


### Двумерные срезы

Массивы и срезы в Go **одномерны**. Чтобы создать эквивалент двумерного массива или среза, необходимо определить **массив массивов или срез срезов**, например:

```go
type Transform [3][3]float64  // 3x3 массив, на самом деле массив массивов.
type LinesOfText [][]byte     // Срез срезов байтов.
```

Поскольку срезы имеют переменную длину, **каждый внутренний срез может иметь разную длину**. Это может быть распространенной ситуацией, как в нашем примере `LinesOfText`: каждая строка имеет независимую длину.

```go
text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

Иногда необходимо выделить двумерный срез, например, при обработке сканирующих строк пикселей. **Существует два способа достичь этого**. Один из способов — выделять каждый срез независимо; другой — выделить один массив и направить в него отдельные срезы. Какой способ использовать, зависит от вашего приложения. Если срезы могут увеличиваться или уменьшаться, их следует выделять независимо, чтобы избежать перезаписи следующей строки; если нет, то может быть эффективнее создать объект с помощью одного выделения памяти. Для справки, вот схемы двух методов. Сначала — строка за строкой:

```go
// Для примера они содержат такие значения.
YSize := 20
XSize := 10
// Выделием срез верхнего уровня.
picture := make([][]uint8, YSize) // Одна строка на единицу y.
// Переберите строки, выделяя срез для каждой строки.
for i := range picture {
    picture[i] = make([]uint8, XSize)
}
```

А теперь — одно выделение, нарезанное на строки:

```go
YSize := 20
XSize := 10
// Выделите срез верхнего уровня, так же как и прежде.
picture := make([][]uint8, YSize) // Одна строка на единицу y.
// Выделите один большой срез для всех пикселей.
pixels := make([]uint8, XSize*YSize) // Имеет тип []uint8, хотя picture — это [][]uint8.
// Переберите строки, нарезая каждую строку из начала оставшегося среза пикселей.
for i := range picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

### Карты

**Карты — это удобная и мощная встроенная структура данных, которая связывает значения одного типа (ключ) со значениями другого типа (элемент или значение)**. Ключ может быть любого типа, для которого определён оператор равенства, например, целые числа, числа с плавающей точкой и комплексные числа, строки, указатели, интерфейсы (если динамический тип поддерживает равенство), структуры и массивы. Срезы не могут использоваться в качестве ключей карт, потому что на них не определено равенство. Подобно срезам, карты хранят ссылки на основную структуру данных. **Если вы передадите карту функции, которая изменяет содержимое карты, изменения будут видны вызывающему коду**.

Карты можно создавать с помощью обычного синтаксиса составного литерала с парами ключ-значение, разделёнными двоеточием, поэтому их легко строить при инициализации.

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

Присваивание и извлечение значений из карты синтаксически выглядит так же, как и для массивов и срезов, за исключением того, что индекс не обязательно должен быть целым числом.

```go
offset := timeZone["EST"]
```

Попытка получить значение карты по ключу, которого нет в карте, **вернёт нулевое значение для типа элементов карты**. Например, если карта содержит целые числа, поиск несуществующего ключа вернёт 0. Множество можно реализовать как карту с типом значения bool. Установите значение карты в true, чтобы добавить значение в множество, а затем проверьте его с помощью простого индексирования.

```go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // будет false, если person нет в карте
    fmt.Println(person, "was at the meeting")
}
```

**Иногда нужно отличить отсутствующую запись от нулевого значения**. Есть ли запись для `"UTC"`, или это 0, потому что её вообще нет в карте? Вы можете узнать это с помощью формы множественного присваивания.

```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

По очевидным причинам это называется идиомой **“comma-ok”**. В этом примере, если `tz` присутствует, `seconds` будет установлен соответственно, а `ok` будет `true`; если нет, `seconds` будет установлен в `0`, а `ok` будет `false`. Вот функция, которая объединяет это с хорошим отчётом об ошибке:

```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

Чтобы проверить присутствие в карте, не беспокоясь о фактическом значении, вы можете использовать пустой идентификатор (_) вместо обычной переменной для значения.

```go
_, present := timeZone[tz]
```

Чтобы удалить запись из карты, используйте встроенную функцию `delete`, аргументы которой — это карта и ключ, который нужно удалить. **Это безопасно, даже если ключ уже отсутствует в карте.**

```go
delete(timeZone, "PDT") // Удаляем ключ "PDT" и его значение, соответственно
```

### Печать

Форматированная печать в Go использует стиль, похожий на семействo функций `printf` в `C`, но более богатый и универсальный. Функции находятся в пакете `fmt` и имеют имена с заглавных букв: `fmt.Printf`, `fmt.Fprintf`, `fmt.Sprintf` и т.д. **Функции строк (например, `Sprintf` и др.) возвращают строку, а не заполняют предоставленный буфер.**

Не обязательно указывать строку формата. Для каждой из функций `Printf`, `Fprintf` и `Sprintf` существуют парные функции, например `Print` и `Println`. Эти функции не принимают строку формата, а вместо этого генерируют формат по умолчанию для каждого аргумента. **Версии `Println` также вставляют пробел между аргументами и добавляют новую строку в вывод**, **тогда как версии `Print` добавляют пробелы только в случае, если операнд с обеих сторон не является строкой**. В этом примере каждая строка производит одинаковый вывод.

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

Форматированные функции печати `fmt.Fprint` и другие принимают в качестве первого аргумента любой объект, реализующий интерфейс `io.Writer`; переменные `os.Stdout` и `os.Stderr` являются знакомыми примерами.

Здесь начинаются отличия от `C`. Во-первых, числовые форматы, такие как `%d`, не принимают флаги для знаковости или размера; вместо этого функции печати используют тип аргумента для определения этих свойств.

```go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```
печатает
```go
18446744073709551615 ffffffffffffffff; -1 -1
```
Если вы хотите получить формат по умолчанию, такой как десятичный для целых чисел, вы можете использовать универсальный формат `%v` (для "значения"); результат будет таким же, как `Print` и `Println`. **Более того, этот формат может печатать любое значение, включая массивы, срезы, структуры и карты**. Вот пример для карты временных зон, определённой в предыдущем разделе.

```go
fmt.Printf("%v\n", timeZone)  // или просто fmt.Println(timeZone)
```
что выводит:

```go
map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]
```

**Для карт функции `Printf` и другие сортируют вывод лексикографически по ключу.**

При печати структуры модифицированный формат `%+v` аннотирует поля структуры их именами, а для любого значения альтернативный формат `%#v` печатает значение в полном синтаксисе Go.

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

печатает

```go
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

**(Обратите внимание на амперсанды.)** Этот формат строки также доступен через `%q`, если применить его к значению типа `string` или `[]byte`. Альтернативный формат `%#q` будет использовать обратные кавычки, если это возможно. (Формат `%q` также применяется к целым числам и рунам, создавая строковую константу с одинарными кавычками.) Также `%x` работает со строками, массивами байтов и срезами байтов, а также с целыми числами, создавая длинную строку в шестнадцатеричном формате, **и при использовании пробела в формате (`% x`) добавляет пробелы между байтами**.

Другой полезный формат — `%T`, который печатает тип значения.

```go
fmt.Printf("%T\n", timeZone)
```

печатает

```go
map[string]int
```

Если вы хотите контролировать формат по умолчанию для пользовательского типа, всё, что нужно сделать, это определить метод с сигнатурой `String() string` для типа. Для нашего простого типа `T` это может выглядеть так.

```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

чтобы напечатать в формате

```go
7/-2.35/"abc\tdef"
```

*(Если вам нужно печатать значения типа `T`, а также указатели на `T`, метод `String` должен быть методом типа значения; в этом примере использован указатель, потому что это более эффективно и идиоматично для структур. См. раздел ниже о получателях значений и указателей для получения дополнительной информации.)*

Наш метод `String` может вызывать `Sprintf`, **поскольку функции печати полностью реентерабельны и могут быть обёрнуты таким образом**. Однако есть важная деталь, которую нужно понять об этом подходе: **не конструируйте метод `String`, вызывая `Sprintf` таким образом, чтобы он рекурсивно вызывал ваш метод `String` бесконечно**. **Это может произойти, если вызов `Sprintf` попытается напечатать получателя напрямую как строку, что, в свою очередь, снова вызовет метод**. Это обычная и легкая ошибка, как показано в этом примере.

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Ошибка.
    // Будет рекурсивно вызываться бесконечно.
}
```

Это также легко исправить: **преобразуйте аргумент к базовому строковому типу, у которого нет метода.**

```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK
    // Обратите внимание на преобразование.
}
```

В разделе инициализации мы увидим ещё одну технику, которая избегает этой рекурсии.

Ещё одна техника печати — это передача аргументов функции печати напрямую другой такой функции. Сигнатура функции `Printf` использует тип `...interface{}` для своего последнего аргумента, чтобы указать, что может быть произвольное количество параметров (произвольного типа) после формата.

```go
func Printf(format string, v ...interface{}) (n int, err error) {
```

Внутри функции `Printf` `v` действует как переменная типа `[]interface{}`, но если она передана другой вариадической функции, она действует как обычный список аргументов. Вот реализация функции `log.Println`, которую мы использовали выше. Она передаёт свои аргументы напрямую в `fmt.Sprintln` для фактического форматирования.

```go
// Println печатает в стандартный логгер, подобно fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output принимает параметры (int, string)
}
```

**Мы пишем `...` после `v` в вложенном вызове `Sprintln`, чтобы указать компилятору рассматривать `v` как список аргументов**; в противном случае он просто передаст `v` как один аргумент в виде среза.

Есть ещё много аспектов печати, которые мы не рассмотрели здесь. См. документацию `godoc` для пакета `fmt` для получения подробной информации.

Кстати, параметр `...` может быть конкретного типа, например, `...int` для функции `min`, которая выбирает минимальное значение из списка целых чисел:

```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // наибольшее целое число
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```
### Добавление (Append)

Теперь у нас есть недостающее звено, которое необходимо для объяснения конструкции встроенной функции `append`. Сигнатура `append` отличается от нашей пользовательской функции `Append`, показанной выше. Схематически она выглядит так:

```go
func append(slice []T, elements ...T) []T
```

где `T` — это заполнитель для любого типа (*`T` — это просто кастомный тип, какой мы захотим. Можем `int`, можем `string`, `rune` или свой тип любой*). В Go нельзя написать функцию, в которой тип `T` определяется вызывающей стороной. Именно поэтому `append` встроена в язык: ей требуется поддержка компилятора.

Что делает `append`, так это добавляет элементы в конец среза и возвращает результат. Результат нужно вернуть, потому что, как и в нашей вручную написанной функции `Append`, исходный массив может измениться. Этот простой пример:

```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

**выводит [1 2 3 4 5 6]**. Таким образом, `append` работает немного как `Printf`, собирая произвольное количество аргументов.

Но что, если бы мы захотели сделать то, что делает наша функция `Append`, и добавить один срез к другому срезу? Легко: используйте `...` в месте вызова, как мы сделали выше в вызове `Output`. Этот фрагмент кода выводит тот же результат, что и предыдущий.

```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

Без `...` код не скомпилируется, потому что типы будут неправильными; `y` не является типом `int`.

## Инициализация (Initialization)

