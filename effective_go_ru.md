# Effective Go (Translated to Russian)

Это переведенный на русский язык Effective Go.

## Содержание


- [Effective Go (Translated to Russian)](#effective-go-translated-to-russian)
  - [Содержание](#содержание)
  - [Форматирование](#форматирование)
    - [Отступы](#отступы)
    - [Длина строки](#длина-строки)
    - [Круглые скобки](#круглые-скобки)
  - [Комментирование](#комментирование)
  - [Имена](#имена)
    - [Имена пакетов](#имена-пакетов)
    - [Геттеры (Getters)](#геттеры-getters)
    - [Имена интерфейсов](#имена-интерфейсов)
    - [MixedCaps](#mixedcaps)
  - [Точки с запятой](#точки-с-запятой)
      - [*Почему именно так?*](#почему-именно-так)
  - [Управляющие конструкции](#управляющие-конструкции)
    - [If](#if)
    - [Повторное объявление и присваивание](#повторное-объявление-и-присваивание)
    - [For](#for)
    - [Switch](#switch)
    - [Type switch](#type-switch)

## Форматирование

Вопросы форматирования - самые спорные, но **наименее значимые**. Люди могут приспособиться к разным стилям форматирования, но лучше, если им не придется этого делать, и меньше времени будет уделено теме, если все будут придерживаться одного стиля. Проблема в том, как подойти к этой утопии без длинного предписывающего руководства по стилю.

В Go мы используем необычный подход и позволяем машине позаботиться о большинстве вопросов форматирования. Программа `gofmt` (также доступная как `go fmt`, которая работает на уровне пакетов, а не исходных файлов) читает программу на Go и выдает исходный текст в стандартном стиле с отступами и вертикальным выравниванием, сохраняя и при необходимости переформатируя комментарии. Если вы хотите узнать, как поступить в новой ситуации с версткой, запустите `gofmt`; если ответ покажется вам неправильным, перестройте свою программу (или напишите об ошибке в `gofmt`), а не обходите ее. 

Например, не нужно тратить время на выстраивание комментариев к полям структуры. `Gofmt` сделает это за вас. Учитывая тэту структуру

```go
type T struct {
    name string // имя объекта
    value int // его значение
}
```

`gofmt` выстроит столбцы в ряд:

```go
type T struct {
    name    string  // имя объекта
    value   int     // его значение
}
```

Весь код Go в стандартных пакетах был отформатирован с помощью `gofmt`.

Некоторые детали форматирования остались. **Очень коротко:**

### Отступы

Мы используем табуляции для отступов, и `gofmt` выдает их по умолчанию. Используйте пробелы только в случае необходимости. 

### Длина строки

В Go нет ограничений на длину строки. Не бойтесь переполнить перфокарту. Если строка кажется слишком длинной, оберните ее и сделайте отступ с помощью дополнительной табуляции. 

Пример:

```go
package main

import "fmt"

func main() {
    // Длинная строка без переноса
    fmt.Println("This is an example of a very long line of code in Go that exceeds the usual length limit and should be wrapped according to best practices for readability and maintainability.")
}

```

```go
package main

import "fmt"

func main() {
    // Длинная строка с множественными переносами
    fmt.Println(
        "This is an example of a very long line of code in Go that exceeds " + 
        "the usual length limit and should be wrapped "+ 
        "according to best practices for readability " +
        "and maintainability.",
    )
}


```

### Круглые скобки

В Go требуется меньше круглых скобок, чем в C и Java: управляющие структуры (if, for, switch) не содержат круглых скобок в своем синтаксисе. Кроме того, иерархия старшинства операторов короче и понятнее, так что

    x<<8 + y<<16

означает то, что подразумевает интервал, в отличие от других языков.

## Комментирование

В Go предусмотрены блочные комментарии `/* */` в стиле `C` и строчные комментарии `//` в стиле `C++`. Строчные комментарии являются нормой; блочные комментарии появляются в основном как комментарии к пакетам, но они полезны внутри выражения или для отключения больших участков кода.

Комментарии, появляющиеся перед декларациями верхнего уровня, без промежуточных строк, считаются документированием самой декларации. Эти «doc-комментарии» являются основной документацией для данного пакета или команды Go. Подробнее о комментариях см. в разделе [Комментарии к документам Go](https://go.dev/doc/comment).

## Имена

Имена важны в Go, как и в любом другом языке. Они даже имеют семантический эффект: **видимость имени вне пакета определяется тем, является ли его первый символ верхним регистром**. Поэтому стоит уделить немного времени обсуждению соглашений об именовании в программах на Go.

### Имена пакетов

Когда пакет импортируется, его имя становится указателем доступа к его содержимому. После импорта пакета:

```go
import "strings"
```

Мы можем использовать его содержимое:

```go
package main

import "strings"

func main() {
    str := "This is the new string!"
    words := strings.SplitN(str, " ", 3)
    // words = ["This","is","the new string!"]
}
bytes.Clone()

```

Мы обращаемся к **экспортируемым** функциям/переменным/структурам через имя пакета. Это удобно, так как все, кто будут использовать этот пакет, будут использовать одинаковое обращение к его содержимому, что подразумевает, что имя пакета должно быть хорошим: коротким, лаконичным, вызывающим. По соглашению, пакетам присваиваются имена в нижнем регистре, состоящие из одного слова; подчеркивания или смешанные прописные буквы не нужны. Отдавайте предпочтение краткости, поскольку все, кто будет использовать ваш пакет, будут набирать это имя. И не беспокойтесь о коллизиях априори. Имя пакета - это только имя по умолчанию для импорта; оно не обязательно должно быть уникальным во всем исходном коде, и в редких случаях коллизии импортирующий пакет может выбрать другое имя для локального использования. 

Например: 

```go
import (
    "strings"
    "github.com/exampleuser/examplelibrary/strings"
    // Будет конфликт, так как оба пакета имеют одинаковые имена указателей доступа.
    // strings и strings
)
```

Сделаем так:

```go
import (
    "strings"
    strings2 "github.com/exampleuser/examplelibrary/strings"
    // Конфликта не будет, как ты локально дали другое название пакету.
)
```

В любом случае, путаница возникает редко, поскольку имя файла в импорте определяет, какой именно пакет используется.

Другое соглашение заключается в том, что имя пакета является базовым именем его исходного каталога; пакет в `src/encoding/base64` импортируется как `"encoding/base64"`, но имеет имя `base64`, а не `encoding_base64` и не `encodingBase64`.

Импортер пакета будет использовать это имя для ссылки на его содержимое, поэтому экспортируемые имена в пакете могут использовать этот факт, чтобы избежать повторений. (Не используйте нотацию `import .`, которая может упростить тесты, которые должны выполняться вне проверяемого пакета, но в остальном ее следует избегать). Например, `buffered reader type` в пакете `bufio` называется `Reader`, а не `BufReader`, потому что пользователи видят его как `bufio.Reader`, **что является ясным и кратким именем**. Более того, поскольку к импортируемым сущностям всегда обращаются по имени их пакета, `bufio.Reader` не конфликтует с `io.Reader`. Аналогично, функция создания новых экземпляров `ring.Ring` - а это определение конструктора в Go - обычно называется `NewRing`, но поскольку `Ring` - единственный тип, экспортируемый пакетом, и поскольку пакет называется `ring`, она называется просто `New`, что клиенты пакета видят как `ring.New`. Используйте структуру пакета, чтобы помочь вам выбрать хорошие имена.

Например, у нас есть пакет `internal/server`, где лежит структура сервера и есть функция, которая создает объект этого сервера. так как мы будем обращаться к содержимому пакета через `server`, во всех экспортируемых именах не стоит ипсользовать `server`.

```go
package server

type server struct {
    // ...
}

func New(...) *server {
    return &server{
        ...
    }
}

// ...
```

```go
package client

import ".../internal/server"

func main() {
    s := server.New(...)
    // ...
}
```

***Что здесь у нас?*** 

У нас есть пакет со структурой сервера и функция, которая инициализирует объект сервера и возвращает указатель на него. **Структура НЕэкспортируемая, а функция экспортируемая**. В другом месте мы импортируем пакет сервера и хотим создать сервер + получить на него указатель. Мы вызываем `server.New()`, **что уже явно говорит нам, что создается именно сервер**. Не надо делать никаких `NewServer()` и других.

Конечно, если будет еще другая структура в этом пакете и у нее будет функция `New()`, то тогда придется выбрать другое название. **А вообще надо просто создать отдельный пакет для этой структуры и всего, что с ней связано.**

### Геттеры (Getters)

Go не предоставляет автоматической поддержки геттеров и сеттеров. Нет ничего плохого в том, чтобы предоставлять геттеры и сеттеры самостоятельно, и часто это бывает уместно, **но нет ни идиоматизма, ни необходимости добавлять Get в имя геттера**. Если у вас есть поле с именем `owner` (**нижний регистр, неэкспортированное**), **метод геттера должен называться `Owner`** (**верхний регистр, экспортированное**), **а не** `GetOwner`. Использование имен в верхнем регистре при экспорте дает крючок для различения поля и метода. Функция сеттера, если она необходима, скорее всего, будет называться `SetOwner`. Оба имени хорошо читаются на практике:
```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Имена интерфейсов

По соглашению, интерфейсы с одним методом называются по имени метода с добавлением суффикса `-er` или аналогичного изменения для образования существительного-агента: `Reader`, `Writer`, `Formatter`, `CloseNotifier` и т.д.

Существует множество таких имен, и важно уважать их и функции, которые они описывают. `Read`, `Write`, `Close`, `Flush`, `String` и так далее **имеют канонические сигнатуры и значения**. Чтобы избежать путаницы, не давайте вашему методу одно из этих имен, если у него нет такой же сигнатуры и значения. Напротив, если ваш тип реализует метод с тем же значением, что и метод в известном типе, дайте ему такое же имя и сигнатуру; назовите ваш метод преобразования строки `String`, а не `ToString`.

***Что за канонические сигнатуры и значения?***

В Go существуют **стандартные (канонические) имена и сигнатуры методов для интерфейсов**. Например, методы `Read`, `Write`, `Close`, и `String` имеют общепринятые значения и способы использования в языке. 

Вот что это означает:

1. *Стандартные имена и сигнатуры*. Методы с определенными именами имеют ожидаемые сигнатуры (определение параметров и возвращаемых значений). Например, метод `Read` в стандартной библиотеке имеет сигнатуру `Read(p []byte) (n int, err error)`, **что означает, что он читает данные в срез байтов и возвращает количество прочитанных байтов и ошибку**.

2. *Согласованность и предсказуемость*. Когда вы используете стандартные имена и сигнатуры, это делает ваш код предсказуемым и совместимым с другими пакетами и библиотеками, которые следуют тем же стандартам. Это помогает другим разработчикам быстрее понять ваш код и использовать его без необходимости разбираться в нестандартных соглашениях.

Не используйте стандартные имена без соответствия сигнатурам: не называйте ваш метод, например, `Read`, **если он не реализует ту же функциональность или сигнатуру, что и стандартный метод `Read`**. Если вы используете стандартное имя, оно должно точно соответствовать общепринятым стандартам, чтобы избежать путаницы. Например, метод `Read` должен принимать **срез байтов** и **возвращать количество прочитанных байтов и ошибку**, как это предусмотрено стандартом.

Соблюдайте соглашения для методов с известными именами: если ваш тип реализует метод, аналогичный методу в известных типах (например, `String` для метода, возвращающего строку), используйте те же имена и сигнатуры. Это делает ваш код согласованным с другими библиотеками и типами, что упрощает его использование и понимание. Например, метод, **который возвращает строковое представление вашего типа, должен называться `String`, а не `ToString`.**

### MixedCaps

Наконец, в Go принято использовать **MixedCaps** или **mixedCaps**, **а не подчеркивание для записи многословных имен**.

## Точки с запятой

Как и в `C`, в формальной грамматике Go используется точка с запятой для завершения операторов, но в отличие от C, эти точки с запятой не появляются в исходном коде. Вместо этого лексический анализатор **(Лексер)** использует простое правило для автоматического добавления точек с запятой во время сканирования, поэтому в тексте программы их почти нет.

Правило такое: *если последний токен перед новой строкой является идентификатором (включая такие слова, как int и float64), простым литералом, таким как число или строковая константа, или одним из следующих токенов:*

```go
break, continue, fallthrough, return, ++, --, ), },
```

*лексический анализатор всегда вставляет точку с запятой после этого токена.* Это можно резюмировать так: **«если новая строка идет после токена, который может завершать оператор, вставьте точку с запятой»**.

Точку с запятой также можно опустить непосредственно перед закрывающей скобкой, поэтому оператор, такой как

```go
go func() { for { dst <- <-src } }()
```

не требует точек с запятой. Идиоматические программы на Go содержат точки с запятой только в таких местах, как условие в цикле for, чтобы разделить инициализацию, условие и продолжение. Они также необходимы для разделения нескольких операторов в одной строке, если вы пишете код таким образом.

Одним из последствий правил вставки точек с запятой является то, **что вы не можете ставить открывающую скобку управляющей структуры (if, for, switch или select) на следующей строке**. Если вы это сделаете, точка с запятой будет вставлена перед скобкой, что может вызвать нежелательные эффекты. Пишите их так:

```go
if i < f() {
    g()
}
```

**а не так:**

```go
if i < f()  // неправильно!
{           // неправильно!
    g()
}
```

#### *Почему именно так?*

Потому что `if i < f()` не заканчивается во втором случае открывающей скобкой, а **значит условие окончено**, а значит лексер поставит точку с запятой. Когда лексер видит конструкцию вида `if i < f() {`, он понимает, что дальше идет тело условия.

*Лексический анализатор сам расставляет точки с запятой перед компиляцией.*

## Управляющие конструкции

Управляющие конструкции в Go похожи на те, что используются в `C`, но имеют важные отличия. В Go нет циклов `do` или `while`, есть только немного более универсальный `for`; конструкция `switch` более гибкая; `if` и `switch` могут принимать необязательный оператор инициализации, подобно `for`; операторы `break` и `continue` могут принимать необязательную метку, чтобы указать, какую конструкцию завершить или продолжить; также есть новые управляющие конструкции, включая `type switch` и мультиплексор многоканальной связи `select`. Синтаксис также немного отличается: **в Go нет круглых скобок**, а **тело конструкций всегда должно быть заключено в фигурные скобки**.

### If

В Go простая конструкция `if` выглядит так:

```go
if x > 0 {
    return y
}
```

Обязательное использование фигурных скобок поощряет написание простых операторов `if` на нескольких строках. **Это хороший стиль, особенно когда тело содержит управляющий оператор, такой как `return` или `break`.**

Поскольку `if` и `switch` могут принимать оператор инициализации, часто можно увидеть, как его используют для создания локальной переменной.

```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

В библиотеках Go вы заметите, что если оператор `if` не переходит к следующему оператору — то есть, если тело заканчивается `break`, `continue`, `goto` или `return` — **то лишний `else` опускается.**

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

Это пример распространенной ситуации, когда код должен защититься от ряда ошибок. Такой код легко читается, если успешное выполнение продолжается вниз по странице, устраняя случаи ошибок по мере их возникновения. Поскольку случаи ошибок обычно заканчиваются операторами `return`, итоговый код не нуждается в операторах `else`.

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

*Пример `type switch`*:

```go
func process(value interface{}) {
    switch v := value.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type\n")
    }
}
```

### Повторное объявление и присваивание

Отступление: последний пример в предыдущем разделе демонстрирует одну деталь, касающуюся того, как работает краткая форма объявления `:=`. Объявление, которое вызывает `os.Open`, выглядит так:

```go
f, err := os.Open(name)
```

Эта инструкция объявляет две переменные: `f` и `err`. Несколькими строками ниже вызов `f.Stat` выглядит так:

```go
d, err := f.Stat()
```

что, на первый взгляд, кажется объявлением переменных `d` и `err`. Обратите внимание, однако, что `err` появляется в обоих выражениях. Это дублирование допустимо: `err` объявляется первым оператором, но во втором только повторно присваивается. Это означает, что вызов `f.Stat` использует существующую переменную `err`, объявленную выше, и просто присваивает ей новое значение.

В декларации `:=` переменная `v` может появляться, даже если она уже была объявлена, при условии, что:

1. Это объявление находится в той же области видимости, что и существующее объявление `v` (если `v` уже объявлена во внешней области видимости, то объявление создаст новую переменную).
2. Соответствующее значение в инициализации может быть присвоено `v`.
3. По крайней мере одна другая переменная создается этим объявлением.

**Это необычное свойство является чистым прагматизмом**, что упрощает использование единственного значения `err`, например, в длинной цепочке `if-else`. Вы часто увидите его использование.

*Примечание: стоит отметить, что в Go область видимости параметров функции и возвращаемых значений совпадает с областью видимости тела функции, даже если они появляются лексически вне фигурных скобок, заключающих тело.*

### For

Цикл `for` в Go похож на цикл в языке `C`, но не идентичен ему. В Go объединены конструкции `for` и `while`, и отсутствует конструкция `do-while`. **Существует три формы цикла `for`, и только в одной из них используются точки с запятой**.

```go
// Как for в C
for init; condition; post { }

// Как while в C
for condition { }

// Как for(;;) в C
for { }
```

Краткие объявления позволяют легко объявлять переменные-счетчики прямо в цикле.

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

Если вы итерируетесь по массиву, срезу, строке, карте или читаете из канала, оператор `range` может управлять циклом.

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

Если вам нужен только первый элемент в `range` (**ключ** или **индекс**), **опустите второй**:

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

Если вам нужен **только второй элемент в `range` (значение), используйте идентификатор-заглушку (подчеркивание) для отбрасывания первого**:

```go
sum := 0
for _, value := range array {
    sum += value
}
```

Идентификатор-заглушка имеет много применений, которые будут описаны в следующих разделах.

Для строк `range` выполняет дополнительную работу, **разбивая отдельные символы Unicode путем парсинга UTF-8**. Ошибочные кодировки потребляют один байт и выводят символ замены `U+FFFD`. (Термин `rune` (и связанный с ним встроенный тип) в Go обозначает **один кодовый пункт Unicode**. Подробнее см. в [спецификации языка](https://go.dev/ref/spec#Rune_literals).)

Цикл

```go
for pos, char := range "日本\x80語" { // \x80 - недопустимая кодировка UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```

выводит:

```go

character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

Наконец, **в Go нет оператора запятой, а ++ и -- — это операторы, а не выражения**. Поэтому, если вы хотите управлять несколькими переменными в `for`, **вы должны использовать параллельное присваивание (хотя это исключает использование ++ и --).**

```go
// Перевернуть массив a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch

Конструкция `switch` в Go более универсальна, чем в `C`. Выражения в `switch` **не обязательно должны быть константами или даже целыми числами**, случаи (`case`) проверяются **сверху вниз до тех пор, пока не будет найдено совпадение**, **и если в `switch` не указано выражение, он переключается на `true`**. Поэтому можно (и это является идиоматикой Go) написать цепочку `if-else-if-else` в виде `switch`.

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

Автоматического перехода к следующему случаю (**`fall through`**) нет, но можно указать несколько значений для одного случая через запятую.

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Хотя `break` в Go используется не так часто, как в некоторых других языках, похожих на `C`, его можно применять для досрочного завершения `switch`. Иногда, однако, требуется выйти из окружающего цикла, а не из `switch`, **и в Go это можно сделать, поместив метку на цикл и используя `break` с указанием этой метки.** Этот пример демонстрирует оба использования.

```go
Loop:
    for n := 0; n < len(src); n += size {
        switch {
        case src[n] < sizeOne:
            if validateOnly {
                break
            }
            size = 1
            update(src[n])

        case src[n] < sizeTwo:
            if n+1 >= len(src) {
                err = errShortInput
                break Loop
            }
            if validateOnly {
                break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
    }
```
Конечно, оператор `continue` также принимает необязательную метку, **но он применяется только к циклам**.

Для завершения этого раздела вот функция сравнения для срезов байтов, которая использует два оператора `switch`:

```go
// Compare возвращает целое число, сравнивающее два среза байтов
// в лексикографическом порядке.
// Результат будет 0, если a == b, -1, если a < b, и +1, если a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### Type switch

`Switch` **также может использоваться для определения динамического типа переменной интерфейса**. Такая проверка типа использует синтаксис проверки типа с ключевым словом `type` внутри скобок. Если `switch` объявляет переменную в выражении, эта переменная будет иметь соответствующий тип в каждом случае. Также **является идиоматическим переиспользование имени в таких случаях**, фактически объявляя новую переменную с тем же именем, но с другим типом в каждом случае.

```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("неожиданный тип %T\n", t)     // %T выводит тип переменной t
case bool:
    fmt.Printf("логическое значение %t\n", t)  // t имеет тип bool
case int:
    fmt.Printf("целое число %d\n", t)          // t имеет тип int
case *bool:
    fmt.Printf("указатель на логическое значение %t\n", *t) // t имеет тип *bool
case *int:
    fmt.Printf("указатель на целое число %d\n", *t) // t имеет тип *int
}
```
